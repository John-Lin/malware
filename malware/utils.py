import os
import dpkt
import socket
import logging
# from pprint import pprint

logging.basicConfig(level=logging.INFO,
                    format='[%(levelname)s] %(message)s',
                    )


def connection_key_2_str(key, combine=False):
    src_ip = socket.inet_ntoa(key[0])
    dst_ip = socket.inet_ntoa(key[2])
    return src_ip + ":" + str(key[1]) + " -> " + dst_ip + ":" + str(key[3])


def follow_tcp_stream(pcapfile):
    connection = {}
    connection2 = {}
    frame_counter = 0
    for ts, buf in dpkt.pcap.Reader(open(pcapfile)):
        frame_counter += 1
        try:
            eth = dpkt.ethernet.Ethernet(buf)
        except:
            continue
        ip = eth.data
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            continue
        if ip.p != dpkt.ip.IP_PROTO_TCP:
            continue

        tcp = ip.data

        connection_key = (ip.src, tcp.sport, ip.dst, tcp.dport)
        logging.debug(connection_key_2_str(connection_key))

        fin_flag = (tcp.flags & dpkt.tcp.TH_FIN) != 0
        syn_flag = (tcp.flags & dpkt.tcp.TH_SYN) != 0
        # rst_flag = (tcp.flags & dpkt.tcp.TH_RST) != 0
        # psh_flag = (tcp.flags & dpkt.tcp.TH_PUSH) != 0
        ack_flag = (tcp.flags & dpkt.tcp.TH_ACK) != 0
        # urg_flag = (tcp.flags & dpkt.tcp.TH_URG) != 0
        # ece_flag = (tcp.flags & dpkt.tcp.TH_ECE) != 0
        # cwr_flag = (tcp.flags & dpkt.tcp.TH_CWR) != 0

        if syn_flag and not ack_flag:
            connection[connection_key] = []
            connection2.setdefault(connection_key, {tcp.seq: {}})
        elif syn_flag and ack_flag:
            connection[connection_key] = []
            connection2.setdefault(connection_key, {tcp.seq: {}})
        elif not syn_flag and ack_flag:
            if connection_key not in connection.keys():
                logging.info(connection_key_2_str(connection_key) +
                             ' Not a complete connection.')
                # Not an complete connection
                connection[connection_key] = []
                connection[connection_key].append(tcp.data)
                connection2.setdefault(connection_key, {tcp.seq: {}})
                connection2[connection_key][tcp.seq] = tcp.data
            else:
                if tcp.data != '':
                    connection[connection_key].append(tcp.data)
                    logging.debug("TCP seq: %d" % tcp.seq)
                    connection2[connection_key][tcp.seq] = tcp.data
                else:
                    logging.debug("TCP seq %d is empty" % tcp.seq)
        elif fin_flag:
            pass
        else:
            pass
    return connection2


def follow_udp_stream(pcapfile):
    connection = {}
    frame_counter = 0
    for ts, buf in dpkt.pcap.Reader(open(pcapfile)):
        frame_counter += 1
        try:
            eth = dpkt.ethernet.Ethernet(buf)
        except:
            continue
        ip = eth.data
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            continue
        if ip.p != dpkt.ip.IP_PROTO_UDP:
            continue

        udp = ip.data
        connection_key = (ip.src, udp.sport, ip.dst, udp.dport)

        if connection_key not in connection.keys():
            connection[connection_key] = []
            connection[connection_key].append(udp.data)
        else:
            if udp.data != '':
                connection[connection_key].append(udp.data)
            else:
                logging.info(udp.data)
    return connection


def tcp_stream(pcapfile):
    connection = {}
    frame_counter = 0
    for ts, buf in dpkt.pcap.Reader(open(pcapfile)):
        frame_counter += 1
        try:
            eth = dpkt.ethernet.Ethernet(buf)
        except:
            continue
        ip = eth.data
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            continue
        if ip.p != dpkt.ip.IP_PROTO_TCP:
            continue
        tcp = ip.data
        if tcp.data == '':
            continue

        tuple_key = (ip.src, tcp.sport, ip.dst, tcp.dport)
        reverse_key = (ip.dst, tcp.dport, ip.src, tcp.sport)

        if (tuple_key and reverse_key) not in connection.keys():
            connection.setdefault(tuple_key, {tcp.seq: tcp.data})
        else:
            connection[reverse_key][tcp.seq] = tcp.data

    return connection
    # for key, value in connection.iteritems():
    #     for key2 in sorted(value.keys()):
    #         print connection_key_2_str(key), key2


def dump_udp_stream_content(connection, save_path, combine=False):
    # save_path = './payload_dump/'
    # if not os.path.isdir(save_path):
    #    os.makedirs(save_path)

    if combine:
        combine_connection = {}
        for tuple_key, value in sorted(connection.iteritems()):
            reverse_key = (tuple_key[2], tuple_key[3],
                           tuple_key[0], tuple_key[1])
            if (tuple_key and reverse_key) not in combine_connection.keys():
                combine_connection[tuple_key] = value
            else:
                combine_connection[reverse_key] = (
                    combine_connection[reverse_key] + value)
    connection = combine_connection

    for key, value in connection.iteritems():
        filename = connection_key_2_str(key).replace(' -> ', '_') + '.out'
        filename = 'udp_' + filename
        w = open(save_path + filename, 'w')
        # value = filter(None, value)
        value = "".join(value)
        w.write(value)
        w.close()
        logging.info('{conn}\t{cont} bytes\tFilename: {fn}'.format(
            conn=connection_key_2_str(key),
            cont=str(len(value)),
            fn=filename))


def dump_tcp_stream_content(connection, save_path, combine=False):
    # Sort TCP sequence number in connection2 (Experimental)
    # connection2:{
    #     HostA:{
    #             Seq1:[payload]
    #             Seq2:[payload]
    #     }
    #     HostB:{
    #         Seq1:[payload]
    #         Seq2:[payload]
    #     }
    # }

    # save_path = './payload_dump/'
    # if not os.path.isdir(save_path):
    #    os.makedirs(save_path)

    if combine:
        combine_connection = {}
        for tuple_key, value in sorted(connection.iteritems()):
            reverse_key = (tuple_key[2], tuple_key[3],
                           tuple_key[0], tuple_key[1])
            if (tuple_key and reverse_key) not in combine_connection.keys():
                combine_connection[tuple_key] = value
            else:
                combine_connection[reverse_key].update(value)
        connection = combine_connection

    for key, value in connection.iteritems():
        # pprint(value)
        content_whole = []
        for key2 in sorted(value.iterkeys()):
            content = "".join(value[key2])
            content_whole.append(content)

        filename = connection_key_2_str(key).replace(' -> ', '_') + '.out'
        filename = 'tcp_' + filename
        w = open(save_path + filename, 'w')
        content_whole = "".join(content_whole)
        w.write(content_whole)
        w.close()
        logging.info('{conn}\t{cont} bytes\tFilename: {fn}'.format(
            conn=connection_key_2_str(key),
            cont=str(len(content_whole)),
            fn=filename))

    # Unsort TCP sequence number in connection
    # connection:{
    #     HostA:[payload, payload, payload]
    #     HostB:[payload, payload, payload]
    # }

    # for key, value in connection.iteritems():
    #     filename = connection_key_2_str(key).replace(' -> ', '_')
    #     w = open(filename, 'w')
    #     # value = filter(None, value)
    #     content = "".join(value)
    #     logging.info(connection_key_2_str(key) + '\t' +
    #                  str(len(content)) + '\t' + filename)
    #     w.write(content)
    #     w.close()

if __name__ == '__main__':
    connection = follow_tcp_stream('./2a.pcap')
    udp_connection = follow_udp_stream('./2a.pcap')
    print('--- TCP ---')
    dump_tcp_stream_content(connection, combine=True)
    print ('--- UDP ---')
    dump_udp_stream_content(udp_connection, combine=True)
