import os
import dpkt
import socket
import logging
# from pprint import pprint

logging.basicConfig(level=logging.INFO,
                    format='[%(levelname)s] %(message)s',
                    )


def connection_key_2_str(key):
    src_ip = socket.inet_ntoa(key[0])
    dst_ip = socket.inet_ntoa(key[2])
    return src_ip + ":" + str(key[1]) + " -> " + dst_ip + ":" + str(key[3])


def follow_tcp_stream(pcapfile):
    connection = {}
    connection2 = {}
    frame_counter = 0
    for ts, buf in dpkt.pcap.Reader(open(pcapfile)):
        frame_counter += 1
        try:
            eth = dpkt.ethernet.Ethernet(buf)
        except:
            continue
        ip = eth.data
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            continue
        if ip.p != dpkt.ip.IP_PROTO_TCP:
            continue

        tcp = ip.data

        connection_key = (ip.src, tcp.sport, ip.dst, tcp.dport)
        logging.debug(connection_key_2_str(connection_key))

        fin_flag = (tcp.flags & dpkt.tcp.TH_FIN) != 0
        syn_flag = (tcp.flags & dpkt.tcp.TH_SYN) != 0
        # rst_flag = (tcp.flags & dpkt.tcp.TH_RST) != 0
        # psh_flag = (tcp.flags & dpkt.tcp.TH_PUSH) != 0
        ack_flag = (tcp.flags & dpkt.tcp.TH_ACK) != 0
        # urg_flag = (tcp.flags & dpkt.tcp.TH_URG) != 0
        # ece_flag = (tcp.flags & dpkt.tcp.TH_ECE) != 0
        # cwr_flag = (tcp.flags & dpkt.tcp.TH_CWR) != 0

        if syn_flag and not ack_flag:
            connection[connection_key] = []
            connection2.setdefault(connection_key, {tcp.seq: {}})
        elif syn_flag and ack_flag:
            connection[connection_key] = []
            connection2.setdefault(connection_key, {tcp.seq: {}})
        elif not syn_flag and ack_flag:
            if connection_key not in connection.keys():
                logging.info(connection_key_2_str(connection_key) +
                             ' Not a complete connection.')
                # Not an complete connection
                connection[connection_key] = []
                connection[connection_key].append(tcp.data)
                connection2.setdefault(connection_key, {tcp.seq: {}})
                connection2[connection_key][tcp.seq] = tcp.data
            else:
                if tcp.data != '':
                    connection[connection_key].append(tcp.data)
                    logging.debug("TCP seq: %d" % tcp.seq)
                    connection2[connection_key][tcp.seq] = tcp.data
                else:
                    logging.debug("TCP seq %d is empty" % tcp.seq)
        elif fin_flag:
            pass
        else:
            pass
    return connection2


def follow_udp_stream(pcapfile):
    connection = {}
    frame_counter = 0
    for ts, buf in dpkt.pcap.Reader(open(pcapfile)):
        frame_counter += 1
        try:
            eth = dpkt.ethernet.Ethernet(buf)
        except:
            continue
        ip = eth.data
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            continue
        if ip.p != dpkt.ip.IP_PROTO_UDP:
            continue

        udp = ip.data
        connection_key = (ip.src, udp.sport, ip.dst, udp.dport)

        if connection_key not in connection.keys():
            connection[connection_key] = []
            connection[connection_key].append(udp.data)
        else:
            if udp.data != '':
                connection[connection_key].append(udp.data)
            else:
                logging.info(udp.data)
    return connection


def dump_udp_stream_content(connection):
    save_path = './payload_dump/'

    if not os.path.isdir(save_path):
        os.makedirs(save_path)

    for key, value in connection.iteritems():
        filename = connection_key_2_str(key).replace(' -> ', '_') + '.out'
        w = open(save_path + filename, 'w')
        # value = filter(None, value)
        value = "".join(value)
        logging.info(connection_key_2_str(key) + '\t' +
                     str(len(value)) + '\t' + filename)
        w.write(value)
        w.close()


def dump_tcp_stream_content(connection):
    # Sort TCP sequence number in connection2 (Experimental)
    # connection2:{
    #     HostA:{
    #             Seq1:[payload]
    #             Seq2:[payload]
    #     }
    #     HostB:{
    #         Seq1:[payload]
    #         Seq2:[payload]
    #     }
    # }
    save_path = './payload_dump/'

    if not os.path.isdir(save_path):
        os.makedirs(save_path)

    for key, value in connection.iteritems():
        # pprint(value)
        filename = connection_key_2_str(key).replace(' -> ', '_') + '.out'
        w = open(save_path + filename, 'w')
        for key2 in sorted(value.iterkeys()):
            content = "".join(value[key2])
            w.write(content)
        w.close()
        logging.info(connection_key_2_str(key) + '\t' +
                     str(len(content)) + '\t' + filename)

    # Unsort TCP sequence number in connection
    # connection:{
    #     HostA:[payload, payload, payload]
    #     HostB:[payload, payload, payload]
    # }

    # for key, value in connection.iteritems():
    #     filename = connection_key_2_str(key).replace(' -> ', '_')
    #     w = open(filename, 'w')
    #     # value = filter(None, value)
    #     content = "".join(value)
    #     logging.info(connection_key_2_str(key) + '\t' +
    #                  str(len(content)) + '\t' + filename)
    #     w.write(content)
    #     w.close()

if __name__ == '__main__':
    connection = follow_tcp_stream('./2a.pcap')
    dump_tcp_stream_content(connection)
