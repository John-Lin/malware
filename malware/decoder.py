import dpkt
import socket
import binascii


def hexify(x):
    h = binascii.hexlify(x)
    tohex = " ".join(h[i:i+2] for i in range(0, len(h), 2))
    return tohex


def truncate_dns(x):
    return x[36:-12]


def _udp_iterator(pc):
    for ts, pkt in pc:
        try:
            eth = dpkt.ethernet.Ethernet(pkt)
        except dpkt.dpkt.NeedData:
            continue

        if eth.type == dpkt.ethernet.ETH_TYPE_IP:
            ip = eth.data
            if ip.p == dpkt.ip.IP_PROTO_UDP:
                udp = ip.data
                yield (ip.src, udp.sport, ip.dst, udp.dport, udp.data)
            else:
                pass
                # Not UDP packets
        else:
            pass
            # Not ether packets
    return


def _tcp_iterator(pc):
    for ts, pkt in pc:
        try:
            eth = dpkt.ethernet.Ethernet(pkt)
        except dpkt.dpkt.NeedData:
            continue

        if eth.type == dpkt.ethernet.ETH_TYPE_IP:
            ip = eth.data
            if ip.p == dpkt.ip.IP_PROTO_TCP:
                tcp = ip.data
                yield (ip.src, tcp.sport, ip.dst, tcp.dport, tcp.data)
            else:
                pass
                # Not TCP packets
        else:
            pass
            # Not ether packets
    return


def decode_dns_qd_name(pcap_path):
    qd_name_list = []
    five_tuple = []
    conn = {}
    fp = open(pcap_path)
    pc = dpkt.pcap.Reader(fp)
    unknown_opcode_counter = 0
    for (src, sport, dst, dport, data) in _udp_iterator(pc):
        if dport == 53:
            key = (src, sport, dst, dport)
            # UDP/53 is a DNS query
            try:
                dns = dpkt.dns.DNS(data)
                conn[key] = [dns.qd[0].name, truncate_dns(hexify(data))]
            except (dpkt.dpkt.UnpackError, IndexError):
                unknown_opcode_counter += 1
                # An unknown opcode maybe malicious traffic
                # print unknown_opcode_counter
                key = (src, sport, dst, dport, unknown_opcode_counter)
                # print 'UNKNOWN_DNS_DATA:', hexify(data)
                conn[key] = ['UNKNOWN_DNS', truncate_dns(hexify(data))]

            # qd_name_list.append(dns.qd[0].name)
            # five_tuple.append((src, sport, dst, dport))
            # print truncate_dns(hexify(data))
            # print "Query for", repr(dns.qd[0].name)
    fp.close()
    return conn


def decode_http_req_header(pcap_path):
    host_list = []
    uri_list = []
    five_tuple = []
    user_agent_list = []
    fp = open(pcap_path)
    pc = dpkt.pcap.Reader(fp)
    for (src, sport, dst, dport, data) in _tcp_iterator(pc):
        if dport == 80 and len(data) > 0:
            key = (src, sport, dst, dport)
            http_req = dpkt.http.Request(data)
            # host_list.append(http_req.headers['host'])
            # uri_list.append(http_req.uri)
            # user_agent_list.append(http_req.headers['user-agent'])
            # five_tuple.append((src, sport, dst, dport))

            conn[key] = [http_req.headers['host'],
                         http_req.uri,
                         http_req.headers['user-agent']]
            # print http_req.headers.keys()
            # print "URI is ", http_req.uri
            # for header in http_req.headers.keys() :
            #     pass
            #     print header, http_req.headers[header]
            # print "method is ", http_req.method
            # print "HTTP headers, packed ", http_req.pack()
            # print "HTTP version", http_req.version
            # print "HTTP data ", http_req.data
    fp.close()
    return conn


if __name__ == '__main__':
    conn = decode_dns_qd_name('./2a.pcap')
    print len(conn)
    conn2 = decode_http_req_header('./2a.pcap')
    print conn2
